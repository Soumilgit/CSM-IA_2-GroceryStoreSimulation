"""Assignment 1 - Grocery Store Events (Task 2)

This file should contain all of the classes necessary to model the different
kinds of events in the simulation.
"""
# Feel free to import classes and functions from
# *your other files*, but remember not to import any external libraries.

from store import *





class Event:
    """An event.

    Events have an ordering based on the event timestamp in non-ascending
    order. Events with older timestamps are less than those with newer
    timestamps.

    This class is abstract; subclasses must implement do().

    You may, if you wish, change the API of this class to add
    extra public methods or attributes. Make sure that anything
    you add makes sense for ALL events, and not just a particular
    event type.

    Document any such changes carefully!

    === Attributes ===
    @type timestamp: int
        A timestamp for this event.
    """
    def __init__(self, timestamp):
        """Initialize an Event with a given timestamp.

        @type self: Event
        @type timestamp: int
            A timestamp for this event.
            Precondition: must be a non-negative integer.
        @rtype: None

        >>> Event(7).timestamp
        7
        """
        self.timestamp = timestamp

    # The following six 'magic methods' are overridden to allow for easy
    # comparison of Event instances. All comparisons simply perform the
    # same comparison on the 'timestamp' attribute of the two events.
    def __eq__(self, other):
        """Return whether this Event is equal to <other>.

        Two events are equal if they have the same timestamp.

        @type self: Event
        @type other: Event
        @rtype: bool

        >>> first = Event(1)
        >>> second = Event(2)
        >>> first == second
        False
        >>> second.timestamp = first.timestamp
        >>> first == second
        True
        """
        return self.timestamp == other.timestamp

    def __ne__(self, other):
        """Return True iff this Event is not equal to <other>.

        @type self: Event
        @type other: Event
        @rtype: bool

        >>> first = Event(1)
        >>> second = Event(2)
        >>> first != second
        True
        >>> second.timestamp = first.timestamp
        >>> first != second
        False
        """
        return not self.__eq__(other)

    def __lt__(self, other):
        """Return True iff this Event is less than <other>.

        @type self: Event
        @type other: Event
        @rtype: bool

        >>> first = Event(1)
        >>> second = Event(2)
        >>> first < second
        True
        >>> second < first
        False
        """
        return self.timestamp < other.timestamp

    def __le__(self, other):
        """Return True iff this Event is less than or equal to <other>.

        @type self: Event
        @type other: Event
        @rtype: bool

        >>> first = Event(1)
        >>> second = Event(2)
        >>> first <= first
        True
        >>> first <= second
        True
        >>> second <= first
        False
        """
        return self.timestamp <= other.timestamp

    def __gt__(self, other):
        """Return True iff this Event is greater than <other>.

        @type self: Event
        @type other: Event
        @rtype: bool

        >>> first = Event(1)
        >>> second = Event(2)
        >>> first > second
        False
        >>> second > first
        True
        """
        return not self.__le__(other)

    def __ge__(self, other):
        """Return True iff this Event is greater than or equal to <other>.

        @type self: Event
        @type other: Event
        @rtype: bool

        >>> first = Event(1)
        >>> second = Event(2)
        >>> first >= first
        True
        >>> first >= second
        False
        >>> second >= first
        True
        """
        return not self.__lt__(other)

    def do(self, store):
        """Perform this Event.

        Call methods on <store> to update its state according to the
        meaning of the event. Note: the "business logic" of what actually
        happens inside a grocery store should be handled in the GroceryStore
        class, not in any Event classes.

        Return a list of new events spawned by this event (making sure the
        timestamps are correct).

        @type self: Event
        @type store: GroceryStore
        @rtype: list[Event]
            A list of events generated by performing this event.
        """
        raise NotImplementedError


# TODO: Create subclasses for the different types of events below.


class EventJoin(Event):
    """A subclass of  Event.
    This is a event when a new customer joins a checkout line
    
    === Attributes ===
    @type timestamp: int
        A timestamp for this event.
    @type customer: Customer
        A customer
    """
    def __init__(self, timestamp, customer):
        super().__init__(timestamp)
        self.timestamp = timestamp
        self.customer = customer

    def do(self, store):
        """Process customer joining a line. Spawn EventBegin if line was empty.
        
        @type store: GroceryStore
        @rtype: list[Event]
        """
        # Track the customer's initial join time for wait calculation
        if not hasattr(self.customer, 'join_time'):
            self.customer.join_time = self.timestamp
        
        # Assign customer to best available line
        line = store.assign_customer(self.customer)
        store.update_customer_to_line(self.customer, line)
        
        # If customer is first in line, they start checkout immediately
        if line.people_in_line == 1:
            return [EventBegin(self.timestamp, self.customer)]
        
        return []


class EventBegin(Event):
    """A subclass of  Event.
    This is a event when a customer begins checking out
    
    === Attributes ===
    @type timestamp: int
        A timestamp for this event.
    @type customer: Customer
        A customer
    """

    def __init__(self, timestamp, customer):
        super().__init__(timestamp)
        self.timestamp = timestamp
        self.customer = customer

    def do(self, store):
        """Customer begins checkout, spawn EventFinish with service time added.
        
        @type store: GroceryStore
        @rtype: list[Event]
        """
        line = store._customer_to_line.get(self.customer)
        if not line:
            return []
        
        n = self.customer.number_of_items
        
        # Calculate service time based on line type
        if isinstance(line, CashierLine):
            checkout_time = store.get_cashier_time(n)
        elif isinstance(line, ExpressLine):
            checkout_time = store.get_express_time(n)
        elif isinstance(line, SelfServeLine):
            checkout_time = store.get_self_serve_time(n)
        else:
            checkout_time = n + 7  # Default
        
        finish_time = self.timestamp + checkout_time
        return [EventFinish(finish_time, self.customer)]



class EventFinish(Event):
    """A subclass of  Event.
    A event when a customer finishes checking out    
    === Attributes ===
    @type timestamp: int
        A timestamp for this event.
    @type customer: Customer
        A customer
    """

    def __init__(self, timestamp, customer):
        super().__init__(timestamp)
        self.timestamp = timestamp
        self.customer = customer

    def do(self, store):
        """Customer finishes checkout. Next customer in line gets EventBegin.
        
        @type store: GroceryStore
        @rtype: list[Event]
        """
        line = store._customer_to_line.get(self.customer)
        if not line:
            return []
        
        # Record finish time for wait calculation
        self.customer.finish_time = self.timestamp
        
        # Remove customer from line
        line.people_in_line -= 1
        
        # Get next customer in line (if any) and start their checkout
        if line.queue and len(line.queue) > 0:
            next_customer = line.queue.pop(0)
            return [EventBegin(self.timestamp, next_customer)]
        
        return []

class EventClose(Event):
    """A subclass of  Event.
    This is a event when a line closes.
    
    === Attributes ===
    @type timestamp: int
        A timestamp for this event.
    @type line_index: int
        Index of the line that is closing
    """

    def __init__(self, timestamp, line_index):
        super().__init__(timestamp)
        self.timestamp = timestamp
        self.line_index = line_index

    def __repr__(self):
        return "EventClose({}, {})".format(repr(self.timestamp), repr(self.line_index))

    def do(self, store):
        """Close a line and reassign customers to other lines.
        
        Customers are spawned new EventJoin events spaced 1 second apart,
        with the last customer having the earliest event (same as close time).
        The first customer in line stays and continues checkout.
        
        @type store: GroceryStore
        @rtype: list[Event]
        """
        if self.line_index < 0 or self.line_index >= len(store._lines):
            return []
        
        line = store._lines[self.line_index]
        line.is_open = False  # Mark line as closed
        
        # Get all customers except the first one (who is being served)
        if not hasattr(line, 'queue') or not line.queue:
            return []
        
        customers_to_reassign = line.queue[:]  # Copy the queue
        line.queue = []  # Clear the queue
        
        # Create new join events for each customer, spaced 1 second apart
        # Last customer in line gets earliest timestamp (close time)
        new_events = []
        num_customers = len(customers_to_reassign)
        
        for i, customer in enumerate(customers_to_reassign):
            # Last customer (highest index) gets timestamp = close time
            # Earlier customers get later timestamps
            event_time = self.timestamp + (num_customers - 1 - i)
            new_events.append(EventJoin(event_time, customer))
        
        return new_events







# TODO: Complete this function, which creates a list of events from a file.
def create_event_list(filename):
    """Return a list of Events based on raw list of events in <filename>.

    Precondition: the file stored at <filename> is in the format specified
    by the assignment handout.

    @param filename: str
        The name of a file that contains the list of events.
    @rtype: list[Event]
    """
    events = []
    with open(filename, 'r') as file:
        for line in file:

            # Create a list of words in the line, e.g.
            # ['60', 'Arrive', 'Bob', '5'].
            # Note that these are strings, and you'll need to convert some of
            # them to ints.

            tokens = line.split()
            if tokens[1] == 'Arrive':
                customer = Customer(tokens[2], int(tokens[-1]))
                events.append(EventJoin(int(tokens[0]), customer))
            elif tokens[1] == 'Close':
                line_index = int(tokens[2])
                events.append(EventClose(int(tokens[0]), line_index))

    return events


if __name__ == '__main__':
    import doctest
    doctest.testmod()
